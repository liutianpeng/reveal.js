<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Go/App服务器设计分享</title>

	<link rel="stylesheet" href="css/reset.css">
	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/night.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/monokai.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
</head>

<body>
	<div class="reveal">
		<div class="slides">

			<section data-markdown>
				## Go/AppServer分享
			</section>

			<section data-markdown>
				### AppServer的主要功能
				- 朋友圈
				- 游戏助手
				- 聊天工具
			</section>

			<section data-markdown>
				### 朋友圈-无状态服务
			</section>

			<section data-markdown>
				### 无状态服务
				- 对单次请求的处理，服务器没有依赖的上下文
				<!-- .element: class="fragment" data-fragment-index="1" -->
				- 不依赖上下文不是没有数据，只是数据都在数据库，服务器程序只负责操作数据
				<!-- .element: class="fragment" data-fragment-index="2" -->
				- 所以无状态的只是AppServer，状态在MongoDB和Redis
				<!-- .element: class="fragment" data-fragment-index="3" -->
			</section>

			<section data-markdown>
				### 无状态服务的好处
				- 用户之间、请求之间没有太多的数据关联
				- 请求之间可以并行，每次请求都可以是一个线程
				- 由于数据都在数据库，所以程序重启产生的影响小
			</section>

			<section data-markdown>
				### Gin
				- Gin是用Go语言实现的HTTP框架
				- App服务器中使用Gin作为Http服务基础框架
				- 使用Gin的中间件设置Header和权限验证
				- 使用Gin的RouterGroup管理api
				- 有关gin的更多信息可以在[Github](https://github.com/gin-gonic/gin)找到
			</section>

			<section data-markdown>
				### 例子
				- 权限验证
					* 通过统一的服务器完成权限验证
					* 验证通过,服务器产生一个Token分别发给App和存到数据库中
					* App请求鉴权,就是把App发来的Token与数据中的Token做比较
				- 发布动态
				- 评论动态
				- 等等...
			</section>

			<section data-markdown>
				### 但是
				- 并不是所有可以完全独立的请求，都能够并发
				- 如果两个请求对同一个数据操作，就有可能产生竞争访问
				- 例如:对动态点赞
			</section>

			<section data-markdown>
				### 对动态点赞
				<pre>
					<code class="go">
					func I_Like_This_Moment(userId uint32, momentID string){
						if I_Dont_Like_It_Before(userId, momentID){
							Add_Moment_Like_Num(momentID, 1)
							I_Do_Like_It(userId, momentID)
						}
					}
					go I_Like_This_Moment(123, "m123")
					go I_Like_This_Moment(123, "m123")
					</code>
				</pre>
				I_Like_This_Moment函数如果在两个线程中调用，可能出现重复点赞
			</section>

			<section data-markdown>
				### 对动态点赞
				- 把竞争访问的部分用数据库的_原子操作_代替
					* 例如Redis，对于每次操作都是原子性的
					* 对于某个动态的点赞列表其实就是一个Set数据结构（用momentID做key）
					* 把点赞操作转化为SADD操作
					* 为了加速访问，把点赞数（SCARD操作）缓存到MongoDB关于动态的文档中
			</section>

			<section data-markdown>
				### 对动态点赞
				- 用_线程池_ 使操作串行化，对于相同动态的点赞操作不并发执行
					* 启动N个线程
					* 利用_momentID_ **mod** _N_ 将每个点赞动态操作布到不同的线程中
					* 保证相同动态的点赞操作在同一线程中执行
			</section>

			<section data-markdown>
				### 对动态点赞
				- 用_锁_ 使操作串行化，对于相同动态的点赞操作不并发执行
					* 使用Go内置的组件_sync.mutex_ 
					* 为了减少锁的粒度，可以做一组（N个）mutex
					* 使用_momentID_ **mod** _N_  选择mutex
			</section>

			<section data-markdown>
				### 对动态点赞
				- 以上的两种操作串行化是在同一个进程中进行
				- 为了在不同进程中也保证操作没有问题
					* 将请求分配到不同的进程是需要遵守一定的规则（也就是引入一个可以负载均衡的Gateway）
					* 使用分布式锁
			</section>

			<section data-markdown>
				### 分布式锁
				- 使用一致性协议实现
					- paxos(zookeeper)
					- raft(etcd)
					- [raft介绍](https://raft.github.io/)
					- [raft动态介绍](http://thesecretlivesofdata.com/raft/)
					- [**龙舟** -go实现的raft库](https://github.com/lni/dragonboat)
				- 使用数据库原子操作实现
					- redis的SET操作的NX属性
			</section>

			<section data-markdown>
				### 基于redis的分布式锁
				- 使用SET操作的NX属性: SET if Not eXists(还有一个方法叫SETNX)
				- [Redis官网文档的介绍](https://redis.io/topics/distlock)
				<pre>
					<code class="lua">
						//加锁: 返回1标识获取锁，返回0标识资源被别人锁定
						SET lock.foo MyRandomData NX PX 5000
						//解锁: 使用lua脚本，保证解除的是自己的锁定
						if redis.call("GET",KEYS[1]) == ARGV[1]
						then
							return redis.call("DEL",KEYS[1])
						else
							return 0
						end
						EVAL ...script... 1 lock.foo MyRandomData
					</code>
				</pre>
			</section>

			<section data-markdown>
				### 为每个新“话题”分配唯一ID
				- 获取话题的唯一ID，成功择返回
				- 通过Incr指令获取一个唯一ID作为备胎
				- 通过SetNX方式设置备胎
				- 如果成功，则备胎转正
				- 如果失败，则重新获取话题的唯一ID
				- 代价：可能有备胎被浪费
			</section>

			<section data-markdown>
				### 小结
				- 对于关联不强的操作，可以设计成无状态的服务
				- 无状态可以是天生的，也可以是被设计出来的
				- 只要对同一数据进行并发操作，就要注意互斥
				- 互斥可以通过安排操作序列实现，也可以通过锁实现
				- 锁的实现可以是集中式的，也可以是分布式的
			</section>

			<section data-markdown>
				### 游戏助手/聊天工具-用消息队列解耦
			</section>

			<section data-markdown>
				### 消息队列
				- 生产者把数据分类，放入队列
				- 消费者按需从队列中获取数据
				- 消息队列解耦了那些信息
					- 生产者不知道，也不需要知道它的数据要给那个消费者处理
					- 消费者也不知道数据是那个生产者发出的
			</section>

			<section data-markdown>
				### 消息队列实现
				- 基于Redis
					- 使用Pub/Sub命令
					- 使用RPush/BLPop命令
				- 用代码实现一个进程中的MQ
					- 用sync.map管理订阅对象者
					- 用函数闭包执行订阅回调
					- 实现一个类似ChannelGroup的属性
			</section>

			<section data-markdown>
				### 来自游戏服务器的消息分发
				- H5服务其实相当于一个转发的路由器
				- 一组线程负责接收来自游戏的消息并发布到不同的主题
					- "zo.区号","ch.CharID","sp.家族ID","co.有区号的国家ID"
				- 每个H5用户处理线程订阅相应的主题
					- 自己的CharID,国家,家族,等等
			</section>

			<section data-markdown>
				### 聊天处理
				- 还是一个路由器
				- 所有聊天请求都发送到聊天管理器
				- 聊天管理器为所有的聊天消息存档并分配相应的主题
					- 主题组织形式：CHAT:游戏ID,聊天类型,区ID,来源ID
				- 每个登陆的app客户端都向聊天管理器订阅自己感兴趣主题(s)
				- 用户在app中切换游戏/游戏区,只用改变订阅的主题
			</section>

			<section data-markdown>
				### 聊天处理-离线消息的处理
			</section>

			<section data-markdown>
				### 聊天处理-离线消息的处理
			</section>


			<section data-markdown>
				## App服务器设计----------------------
			</section>


			<section data-markdown>
				<script type="text/template">
# 无状态的服务
- 对单次请求的处理，服务器没有依赖的上下文<!-- .element: class="fragment" data-fragment-index="1" -->
- 所以请求可以并行，每次请求都可以是一个goroutine<!-- .element: class="fragment" data-fragment-index="2" -->
- 不依赖上下文不是没有数据，只是数据都在数据库，服务器程序只负责操作数据<!-- .element: class="fragment" data-fragment-index="3" -->
- 所以无状态的只是AppServer<!-- .element: class="fragment" data-fragment-index="4" -->
				</script>
			</section>
			<section>
				<section>
					<p>After 2 seconds the first fragment will be shown.</p>
					<p class="fragment" data-autoslide="10000">After 10 seconds the next fragment will be shown.</p>
					<p class="fragment">Now, the fragment is displayed for 2 seconds before the next slide is shown.</p>
				</section>
				<section>
					Vertical Slide 1
				</section>
				<section>
					Vertical Slide 2
				</section>
			</section>
			<section>
				Slide 2
				<p>There's a <a data-preview-link href="https://github.com/hakimel/reveal.js#speaker-notes">speaker
						view</a>. It
					includes a timer,
					preview of the upcoming slide as well as your speaker notes.</p>
			</section>
			<section data-background-iframe="https://bing.com" data-background-interactive>
				<h2>Iframe</h2>
			</section>
		</div>
	</div>

	<script src="js/reveal.js"></script>

	<script>
		// More info about config & dependencies:
		// - https://github.com/hakimel/reveal.js#configuration
		// - https://github.com/hakimel/reveal.js#dependencies
		Reveal.initialize({
			controls: true,
			slideNumber: true,
			hash: true,
			navigationMode: 'default',
			transition: 'slide', // none/fade/slide/convex/concave/zoom
			transitionSpeed: 'default', // default/fast/slow
			backgroundTransition: 'fade', // none/fade/slide/convex/concave/zoom
			embedded: false,
			hideAddressBar: true,
			previewLinks: false,

			//width: 960,
			//height: 700,
			margin: 0,

			dependencies: [
				{ src: 'plugin/markdown/marked.js' },
				{ src: 'plugin/markdown/markdown.js' },
				{ src: 'plugin/notes/notes.js', async: true },
				{ src: 'plugin/highlight/highlight.js', async: true },
				{ src: 'socket.io/socket.io.js', async: true },
				{ src: 'plugin/notes-server/client.js', async: true },
				{ src: 'socket.io/socket.io.js', async: true },
				{ src: 'plugin/notes-server/client.js', async: true }
			]
		})

	</script>
</body>

</html>